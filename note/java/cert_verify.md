# Certificate verification
## basic concept
### 对称加密算法 (symmetric key algorithms)
* 加密和解密使用的密钥是同一个密钥
* 算法比较块，但需要把密钥做好保密
### 非对称加密算法
* 加密和解密使用的密钥不同
* 公钥密码体制 (RSA)
  * 公钥, 私钥, 加密算法。
  * 用公钥加密的只有私钥解密，私钥加密的只有公钥可以解密。
  * 公钥和加密算法是公开的。
### 加密和签名
* 加密: 对某个信息或内容加密形成密文
* 签名
  * 用一个hash算法对信息做hash计算得到一个hash值(不可逆：无法有hash值还原信息)。
  * 这个hash值加密后就是签名
  * 把hash算法，签名和原信息一起发出，接收着可以用hash算法计算信息得到hash值和签名解密出来的hash值做比较，以防止信息被篡改

## 加密通信
### 简单模拟过程
1. "客户" -> "服务器": 你好
2. "服务器" -> "客户": 你好，我是服务器
3. "客户" -> "服务器": 向我证明是你服务器
4. "服务器" -> "客户": 你好，我是服务器 {你好，我是服务器}[私钥|RSA]
   * (约定 {} 表示加密后的内容，[ | ]表示用什么密钥和算法进去加密。)
5. "客户" -> "服务器": {我们后面用对称加密通信，这是对称加密算法和密钥}[公钥|RSA]
6. "服务器" -> "客户": {OK，收到！}[密钥|对称加密算法]
7. "客户" -> "服务器": {我的账号是aaa, 密码是123， 把我的余额信息发给我看看}[密钥|对称加密算法]
8. "服务器" -> "客户": {你的当前余额是100元}[密钥|对称加密算法]
   * RSA起到两个作用
     1. 私钥只有"服务器"拥有，可以用来判断对方是否是"服务器"
     2. 通过RSA做掩护，安全的与"服务器"协商好一个对称加密算法和密钥来保证后面通信过程内容的安全

### 数字证书
* 证书颁发机构 (issuer)
* 证书有效期
* 公钥 (public key)
* 证书所有者 (subject)
* 指纹算法: 计算整个证书的hash值用到的hash算法
* 指纹
  * 用来保证证书的完整性，确保证书没有被修改过
  * 用指纹算法对整个证书算出一个hash值作为指纹
* 签名算法： 生产签名所用的加密算法
* 签名
  * 证书颁发机构用签名算法和它自己的私钥对颁发的证书里面的指纹和指纹算法做加密，形成的密文就是签名
  * 客户端可以用证书颁发机构本身的证书里的公钥加密服务器证书的指纹和指纹算法，然后用指纹算法对服务器的证书hash一个指和指纹匹配，防止服务器证书被修改

### 客户端通过服务器数字证书获取服务器公钥
1. "客户" -> "服务器": 你好
2. "服务器" -> "客户": 你好，我是服务器，这是我的证书
   * (客户端可以做证书校验, 获取服务器公钥)
3. "客户" -> "服务器": 向我证明是你服务器，这是一个随机字符串
4. "服务器" -> "客户": {随机字符串}[私钥|RSA]
5. "客户" -> "服务器": {我们后面用对称加密通信，这是对称加密算法和密钥}[公钥|RSA]
6. "服务器" -> "客户": {OK，收到！}[密钥|对称加密算法]
7. "客户" -> "服务器": {我的账号是aaa, 密码是123， 把我的余额信息发给我看看}[密钥|对称加密算法]
8. "服务器" -> "客户": {你的当前余额是100元}[密钥|对称加密算法]

